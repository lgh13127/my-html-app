<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>å£°ç½‘éŸ³é¢‘é€šè¯ç¤ºä¾‹</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        /* æ ·å¼éƒ¨åˆ†æ— ä¿®æ”¹ï¼Œä¿ç•™åŸæœ‰æ ·å¼ */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', 'Microsoft YaHei', sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1000px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            overflow: hidden;
            padding: 30px;
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #f0f0f0;
        }
        
        .header h1 {
            color: #333;
            font-size: 28px;
            margin-bottom: 10px;
        }
        
        .header p {
            color: #666;
            font-size: 16px;
        }
        
        .control-panel {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 30px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.05);
        }
        
        .input-group {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        
        .input-field {
            flex: 1;
            min-width: 200px;
        }
        
        .input-field label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #555;
            font-size: 14px;
        }
        
        .input-field input {
            width: 100%;
            padding: 15px;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            font-size: 16px;
            transition: all 0.3s;
        }
        
        .input-field input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }
        
        .input-field input::placeholder {
            color: #aaa;
        }
        
        .token-hint {
            font-size: 12px;
            color: #888;
            margin-top: 5px;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .token-hint i {
            color: #ff9800;
        }
        
        .button-group {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        
        button {
            padding: 15px 30px;
            border: none;
            border-radius: 10px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            min-width: 140px;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }
        
        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none !important;
            box-shadow: none !important;
        }
        
        .call-btn {
            background: linear-gradient(to right, #667eea, #764ba2);
            color: white;
        }
        
        .call-btn:hover {
            background: linear-gradient(to right, #5a6fd8, #6b4190);
        }
        
        .call-btn.in-call {
            background: linear-gradient(to right, #ff6b6b, #ff5252);
        }
        
        .call-btn.in-call:hover {
            background: linear-gradient(to right, #ff5252, #e53935);
        }
        
        .mic-btn {
            background: #4CAF50;
            color: white;
        }
        
        .mic-btn:hover {
            background: #43a047;
        }
        
        .mic-btn.muted {
            background: #ff6b6b;
        }
        
        .mic-btn.muted:hover {
            background: #ff5252;
        }
        
        .members-container {
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.05);
        }
        
        .members-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #f0f0f0;
        }
        
        .members-header h2 {
            color: #333;
            font-size: 22px;
        }
        
        .members-count {
            background: #667eea;
            color: white;
            padding: 5px 15px;
            border-radius: 20px;
            font-weight: 600;
        }
        
        .members-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 20px;
        }
        
        .member-card {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 20px;
            display: flex;
            align-items: center;
            gap: 15px;
            transition: all 0.3s;
            border: 2px solid transparent;
        }
        
        .member-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.08);
            border-color: #667eea;
        }
        
        .member-card.local {
            background: linear-gradient(135deg, #e3f2fd, #f3e5f5);
        }
        
        .avatar {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            font-weight: bold;
            color: white;
            flex-shrink: 0;
        }
        
        .avatar.local {
            background: linear-gradient(135deg, #667eea, #764ba2);
        }
        
        .avatar.remote {
            background: linear-gradient(135deg, #4CAF50, #2E7D32);
        }
        
        .member-info {
            flex: 1;
        }
        
        .member-name {
            font-weight: 600;
            color: #333;
            font-size: 18px;
            margin-bottom: 5px;
        }
        
        .member-uid {
            color: #666;
            font-size: 14px;
            margin-bottom: 8px;
        }
        
        .member-status {
            display: inline-flex;
            align-items: center;
            gap: 5px;
            padding: 3px 10px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 600;
        }
        
        .status-online {
            background: #e8f5e9;
            color: #2E7D32;
        }
        
        .status-muted {
            background: #ffebee;
            color: #c62828;
        }
        
        .status-speaker {
            background: #e3f2fd;
            color: #1565c0;
        }
        
        .member-actions {
            display: flex;
            gap: 8px;
        }
        
        .action-btn {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
            font-size: 18px;
        }
        
        .mute-btn {
            background: #ffebee;
            color: #c62828;
        }
        
        .mute-btn:hover {
            background: #ffcdd2;
        }
        
        .mute-btn.muted {
            background: #e0e0e0;
            color: #616161;
        }
        
        .empty-state {
            text-align: center;
            padding: 40px 20px;
            color: #666;
        }
        
        .empty-state i {
            font-size: 48px;
            margin-bottom: 20px;
            display: block;
        }
        
        .footer {
            text-align: center;
            margin-top: 30px;
            color: #666;
            font-size: 14px;
            padding-top: 20px;
            border-top: 1px solid #eee;
        }
        
        .call-status {
            text-align: center;
            margin: 20px 0;
            padding: 15px;
            border-radius: 10px;
            background: #f8f9fa;
            font-weight: 600;
            display: none;
        }
        
        .call-status.connected {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        
        .call-status.disconnected {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        
        /* æ–°å¢ï¼šéŸ³é¢‘è®¾å¤‡é€‰æ‹©å™¨æ ·å¼ */
        .device-selector {
            margin-top: 20px;
            padding: 20px;
            background: #f0f7ff;
            border-radius: 12px;
            border-left: 4px solid #667eea;
        }
        
        .device-selector h3 {
            margin-bottom: 15px;
            color: #333;
            font-size: 18px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .device-selector h3 i {
            color: #667eea;
        }
        
        .device-row {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 15px;
        }
        
        .device-group {
            flex: 1;
            min-width: 200px;
        }
        
        .device-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #555;
            font-size: 14px;
        }
        
        .device-select {
            width: 100%;
            padding: 12px 15px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 14px;
            background: white;
            color: #333;
            transition: all 0.3s;
            cursor: pointer;
        }
        
        .device-select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }
        
        .device-select:disabled {
            background: #f5f5f5;
            color: #999;
            cursor: not-allowed;
        }
        
        .device-status {
            margin-top: 8px;
            font-size: 12px;
            color: #666;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .device-status.active {
            color: #2E7D32;
        }
        
        .device-status.inactive {
            color: #c62828;
        }
        
        .device-actions {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        
        .refresh-btn {
            padding: 10px 15px;
            background: #6c757d;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .refresh-btn:hover {
            background: #5a6268;
            transform: translateY(-1px);
        }
        
        .refresh-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none !important;
        }
        
        .test-btn {
            padding: 10px 15px;
            background: #17a2b8;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .test-btn:hover {
            background: #138496;
            transform: translateY(-1px);
        }
        
        .test-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none !important;
        }
        
        .volume-meter {
            margin-top: 10px;
            height: 8px;
            background: #e0e0e0;
            border-radius: 4px;
            overflow: hidden;
            position: relative;
            display: none;
        }
        
        .volume-level {
            height: 100%;
            background: linear-gradient(to right, #4CAF50, #8BC34A, #FFEB3B, #FF9800, #F44336);
            border-radius: 4px;
            transition: width 0.1s ease;
        }
        
        /* æ–°å¢ï¼šåª’ä½“æºé€‰é¡¹æ ·å¼ */
        .source-group {
            margin-bottom: 15px;
        }
        
        .source-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #555;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .source-options {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .source-option {
            display: flex;
            align-items: center;
            gap: 5px;
            cursor: pointer;
            padding: 8px 12px;
            border-radius: 6px;
            background: #f0f0f0;
            transition: all 0.3s;
        }
        
        .source-option:hover {
            background: #e0e0e0;
        }
        
        .source-option.active {
            background: #e3f2fd;
            border: 1px solid #667eea;
        }
        
        .source-option input[type="radio"] {
            margin: 0;
        }
        
        .source-option label {
            margin: 0;
            font-weight: normal;
            cursor: pointer;
        }
        
        /* æ–°å¢ï¼šéŸ³é¢‘å¤„ç†é€‰é¡¹æ ·å¼ */
        .processing-group {
            margin-top: 15px;
        }
        
        .processing-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #555;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .processing-options {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }
        
        .processing-option {
            display: flex;
            align-items: center;
            gap: 5px;
            cursor: pointer;
            padding: 8px 12px;
            border-radius: 6px;
            background: #f0f0f0;
            transition: all 0.3s;
        }
        
        .processing-option:hover {
            background: #e0e0e0;
        }
        
        .processing-option.active {
            background: #e8f5e9;
            border: 1px solid #4CAF50;
        }
        
        .processing-option input[type="checkbox"] {
            margin: 0;
        }
        
        .processing-option label {
            margin: 0;
            font-weight: normal;
            cursor: pointer;
        }
        
        .tooltip {
            font-size: 12px;
            color: #666;
            margin-left: 4px;
            cursor: help;
        }
        
        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }
            
            .input-group {
                flex-direction: column;
            }
            
            .input-field {
                width: 100%;
            }
            
            .button-group {
                justify-content: center;
            }
            
            button {
                flex: 1;
                min-width: 120px;
            }
            
            .members-list {
                grid-template-columns: 1fr;
            }
            
            .device-row {
                flex-direction: column;
            }
            
            .device-group {
                min-width: 100%;
            }
            
            .source-options {
                flex-direction: column;
            }
            
            .processing-options {
                flex-direction: column;
            }
        }
        
        @media (max-width: 480px) {
            .button-group {
                flex-direction: column;
            }
            
            button {
                width: 100%;
            }
            
            .device-actions {
                flex-direction: column;
            }
        }
    </style>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ¤ å£°ç½‘éŸ³é¢‘é€šè¯</h1>
            <p>éšæ—¶éšåœ°ï¼Œæ¸…æ™°é€šè¯ | æ”¯æŒå¤šäººè¯­éŸ³ä¼šè®®</p>
        </div>
        
        <div class="control-panel">
            <div class="input-group">
                <div class="input-field">
                    <label for="channelName"><i class="fas fa-hashtag"></i> é¢‘é“åç§°</label>
                    <input type="text" id="channelName" placeholder="è¯·è¾“å…¥é¢‘é“åç§°ï¼Œå¦‚ï¼šmeeting-room-1">
                </div>
                
                <div class="input-field">
                    <label for="tokenInput"><i class="fas fa-key"></i> é‰´æƒä»¤ç‰Œ (Token)</label>
                    <input type="text" id="tokenInput" placeholder="è¯·è¾“å…¥é‰´æƒä»¤ç‰Œ (å¯é€‰)">
                    <div class="token-hint">
                        <i class="fas fa-info-circle"></i>
                        <span>åœ¨å®‰å…¨æ¨¡å¼ä¸‹éœ€è¦Tokenï¼Œæµ‹è¯•æ—¶å¯ç•™ç©ºä½¿ç”¨ä¸´æ—¶Token</span>
                    </div>
                </div>
            </div>
            
            <div class="button-group">
                <button class="call-btn" id="callToggle">
                    <i class="fas fa-phone-alt"></i>
                    <span id="callText">åŠ å…¥é€šè¯</span>
                </button>
                <button class="mic-btn" id="micToggle" disabled>
                    <i class="fas fa-microphone"></i>
                    <span id="micText">å¼€å¯è¯ç­’</span>
                </button>
            </div>
            
            <!-- éŸ³é¢‘è®¾å¤‡é€‰æ‹©å™¨ -->
            <div class="device-selector">
                <h3><i class="fas fa-sliders-h"></i> éŸ³é¢‘è®¾å¤‡è®¾ç½®</h3>
                
                <!-- æ–°å¢ï¼šåª’ä½“æºé€‰æ‹© -->
                <div class="source-group">
                    <label><i class="fas fa-wave-square"></i> éŸ³é¢‘æ¥æº</label>
                    <div class="source-options">
                        <div class="source-option active" id="micSourceOption">
                            <input type="radio" id="micSource" name="audioSource" value="microphone" checked>
                            <label for="micSource">éº¦å…‹é£</label>
                        </div>
                        <div class="source-option" id="systemAudioSourceOption">
                            <input type="radio" id="systemAudioSource" name="audioSource" value="system">
                            <label for="systemAudioSource">ç³»ç»ŸéŸ³é¢‘</label>
                        </div>
                        <div class="source-option" id="screenAudioSourceOption">
                            <input type="radio" id="screenAudioSource" name="audioSource" value="screen">
                            <label for="screenAudioSource">å±å¹•éŸ³é¢‘</label>
                        </div>
                        <div class="source-option" id="micScreenSourceOption">
                            <input type="radio" id="micScreenSource" name="audioSource" value="mic+screen">
                            <label for="micScreenSource">è¯ç­’+å±å¹•éŸ³é¢‘</label>
                        </div>
                    </div>
                </div>
                
                <div class="device-row">
                    <div class="device-group">
                        <label for="micSelect"><i class="fas fa-microphone"></i> éº¦å…‹é£ï¼ˆè¾“å…¥è®¾å¤‡ï¼‰</label>
                        <select id="micSelect" class="device-select" disabled>
                            <option value="">æ­£åœ¨è·å–è®¾å¤‡åˆ—è¡¨...</option>
                        </select>
                        <div id="micStatus" class="device-status inactive">
                            <i class="fas fa-circle"></i>
                            <span>æœªé€‰æ‹©éº¦å…‹é£</span>
                        </div>
                    </div>
                    
                    <div class="device-group">
                        <label for="speakerSelect"><i class="fas fa-volume-up"></i> æ‰¬å£°å™¨ï¼ˆè¾“å‡ºè®¾å¤‡ï¼‰</label>
                        <select id="speakerSelect" class="device-select" disabled>
                            <option value="">æ­£åœ¨è·å–è®¾å¤‡åˆ—è¡¨...</option>
                        </select>
                        <div id="speakerStatus" class="device-status inactive">
                            <i class="fas fa-circle"></i>
                            <span>ä½¿ç”¨é»˜è®¤æ‰¬å£°å™¨</span>
                        </div>
                    </div>
                </div>
                
                <!-- æ–°å¢ï¼šéŸ³é¢‘å¤„ç†é€‰é¡¹ -->
                <div class="processing-group">
                    <label><i class="fas fa-magic"></i> éŸ³é¢‘å¤„ç†</label>
                    <div class="processing-options">
                        <div class="processing-option active" id="aecOption">
                            <input type="checkbox" id="aecToggle" checked>
                            <label for="aecToggle">å›å£°æ¶ˆé™¤</label>
                        </div>
                        <div class="processing-option active" id="ansOption">
                            <input type="checkbox" id="ansToggle" checked>
                            <label for="ansToggle">é™å™ª</label>
                        </div>
                        <div class="processing-option active" id="agcOption">
                            <input type="checkbox" id="agcToggle" checked>
                            <label for="agcToggle">è‡ªåŠ¨å¢ç›Š</label>
                        </div>
                    </div>
                </div>
                
                <div class="volume-meter" id="volumeMeter">
                    <div class="volume-level" id="volumeLevel" style="width: 0%"></div>
                </div>
                
                <div class="device-actions">
                    <button class="refresh-btn" id="refreshDevices">
                        <i class="fas fa-sync-alt"></i>
                        <span>åˆ·æ–°è®¾å¤‡åˆ—è¡¨</span>
                    </button>
                    <button class="test-btn" id="testMic">
                        <i class="fas fa-play"></i>
                        <span>æµ‹è¯•éº¦å…‹é£</span>
                    </button>
                </div>
            </div>
            
            <div id="callStatus" class="call-status">
                <i class="fas fa-circle-notch fa-spin"></i>
                <span id="statusText">æ­£åœ¨è¿æ¥...</span>
            </div>
        </div>
        
        <div class="members-container">
            <div class="members-header">
                <h2><i class="fas fa-users"></i> é€šè¯æˆå‘˜</h2>
                <div class="members-count">
                    <span id="memberCount">0</span> äººåœ¨çº¿
                </div>
            </div>
            
            <div id="membersList" class="members-list">
                <div class="empty-state">
                    <i class="fas fa-user-friends"></i>
                    <p>é¢‘é“å†…æš‚æ— æˆå‘˜</p>
                    <p style="font-size: 12px; margin-top: 5px;">åŠ å…¥é¢‘é“åï¼Œæˆå‘˜åˆ—è¡¨å°†åœ¨è¿™é‡Œæ˜¾ç¤º</p>
                </div>
            </div>
        </div>
        
        <div class="footer">
            <p>Powered by Agora Web SDK v4.21.0 | ç¡®ä¿ä½¿ç”¨HTTPSç¯å¢ƒæˆ–localhost</p>
        </div>
    </div>

    <!-- å¼•å…¥å£°ç½‘ Web SDKï¼ˆæ¨èæœ€æ–°ç¨³å®šç‰ˆï¼‰ -->
    <script src="https://download.agora.io/sdk/release/AgoraRTC_N-4.21.0.js"></script>
    <script>
        // å…¨å±€å˜é‡
        let rtcClient = null;
        let localAudioTrack = null;
        let localScreenAudioTrack = null;
        let isPublished = false;
        let isMicrophoneMuted = true;
        let isInCall = false;
        let members = new Map();
        const APP_ID = "4531524ecba946fd868fc547c6d269d7";
        
        // æ–°å¢éŸ³é¢‘è®¾å¤‡ç›¸å…³å˜é‡
        let audioInputDevices = [];
        let audioOutputDevices = [];
        let selectedMicDeviceId = '';
        let selectedSpeakerDeviceId = '';
        let testAudioContext = null;
        let testAudioAnalyser = null;
        let testAudioStream = null;
        let isTestingMic = false;
        
        // æ–°å¢ï¼šåª’ä½“æºå’ŒéŸ³é¢‘å¤„ç†å˜é‡
        let currentAudioSource = 'microphone'; // 'microphone', 'system', 'screen', 'mic+screen'
        let audioProcessingOptions = {
            AEC: true,  // å›å£°æ¶ˆé™¤
            ANS: true,  // å™ªå£°æŠ‘åˆ¶
            AGC: true   // è‡ªåŠ¨å¢ç›Šæ§åˆ¶
        };
        
        // DOMå…ƒç´ å¼•ç”¨
        let callToggleBtn, micToggleBtn, callTextSpan, micTextSpan;
        let callStatusDiv, statusTextSpan;
        let channelNameInput, tokenInput, membersListDiv, memberCountSpan;
        let micSelect, speakerSelect, refreshDevicesBtn, testMicBtn;
        let micStatusDiv, speakerStatusDiv, volumeMeter, volumeLevel;
        
        // æ–°å¢ï¼šåª’ä½“æºå’ŒéŸ³é¢‘å¤„ç†DOMå…ƒç´ 
        let micSourceOption, systemAudioSourceOption, screenAudioSourceOption, micScreenSourceOption;
        let micSourceRadio, systemAudioSourceRadio, screenAudioSourceRadio, micScreenSourceRadio;
        let aecOption, ansOption, agcOption;
        let aecToggle, ansToggle, agcToggle;
        
        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
        window.addEventListener('DOMContentLoaded', async function() {
            // è·å–DOMå…ƒç´ 
            callToggleBtn = document.getElementById('callToggle');
            micToggleBtn = document.getElementById('micToggle');
            callTextSpan = document.getElementById('callText');
            micTextSpan = document.getElementById('micText');
            callStatusDiv = document.getElementById('callStatus');
            statusTextSpan = document.getElementById('statusText');
            channelNameInput = document.getElementById('channelName');
            tokenInput = document.getElementById('tokenInput');
            membersListDiv = document.getElementById('membersList');
            memberCountSpan = document.getElementById('memberCount');
            
            // è·å–è®¾å¤‡é€‰æ‹©ç›¸å…³DOMå…ƒç´ 
            micSelect = document.getElementById('micSelect');
            speakerSelect = document.getElementById('speakerSelect');
            refreshDevicesBtn = document.getElementById('refreshDevices');
            testMicBtn = document.getElementById('testMic');
            micStatusDiv = document.getElementById('micStatus');
            speakerStatusDiv = document.getElementById('speakerStatus');
            volumeMeter = document.getElementById('volumeMeter');
            volumeLevel = document.getElementById('volumeLevel');
            
            // æ–°å¢ï¼šè·å–åª’ä½“æºå’ŒéŸ³é¢‘å¤„ç†DOMå…ƒç´ 
            micSourceOption = document.getElementById('micSourceOption');
            systemAudioSourceOption = document.getElementById('systemAudioSourceOption');
            screenAudioSourceOption = document.getElementById('screenAudioSourceOption');
            micScreenSourceOption = document.getElementById('micScreenSourceOption');
            micSourceRadio = document.getElementById('micSource');
            systemAudioSourceRadio = document.getElementById('systemAudioSource');
            screenAudioSourceRadio = document.getElementById('screenAudioSource');
            micScreenSourceRadio = document.getElementById('micScreenSource');
            
            aecOption = document.getElementById('aecOption');
            ansOption = document.getElementById('ansOption');
            agcOption = document.getElementById('agcOption');
            aecToggle = document.getElementById('aecToggle');
            ansToggle = document.getElementById('ansToggle');
            agcToggle = document.getElementById('agcToggle');
            
            // ç»‘å®šäº‹ä»¶ç›‘å¬å™¨
            if (callToggleBtn) {
                callToggleBtn.addEventListener('click', toggleCall);
            }
            
            if (micToggleBtn) {
                micToggleBtn.addEventListener('click', toggleMicrophone);
            }
            
            // ç»‘å®šè®¾å¤‡é€‰æ‹©äº‹ä»¶
            if (micSelect) {
                micSelect.addEventListener('change', onMicDeviceChange);
            }
            
            if (speakerSelect) {
                speakerSelect.addEventListener('change', onSpeakerDeviceChange);
            }
            
            if (refreshDevicesBtn) {
                refreshDevicesBtn.addEventListener('click', refreshAudioDevices);
            }
            
            if (testMicBtn) {
                testMicBtn.addEventListener('click', toggleMicTest);
            }
            
            // æ–°å¢ï¼šç»‘å®šåª’ä½“æºé€‰æ‹©äº‹ä»¶
            if (micSourceRadio) {
                micSourceRadio.addEventListener('change', onAudioSourceChange);
            }
            
            if (systemAudioSourceRadio) {
                systemAudioSourceRadio.addEventListener('change', onAudioSourceChange);
            }
            
            if (screenAudioSourceRadio) {
                screenAudioSourceRadio.addEventListener('change', onAudioSourceChange);
            }
            
            if (micScreenSourceRadio) {
                micScreenSourceRadio.addEventListener('change', onAudioSourceChange);
            }
            
            // æ–°å¢ï¼šç»‘å®šéŸ³é¢‘å¤„ç†é€‰é¡¹äº‹ä»¶
            if (aecToggle) {
                aecToggle.addEventListener('change', onAudioProcessingChange);
            }
            
            if (ansToggle) {
                ansToggle.addEventListener('change', onAudioProcessingChange);
            }
            
            if (agcToggle) {
                agcToggle.addEventListener('change', onAudioProcessingChange);
            }
            
            // è®¾ç½®åˆå§‹çŠ¶æ€
            updateMembersDisplay();
            
            // ç›‘å¬é¡µé¢å¯è§æ€§å˜åŒ–
            document.addEventListener('visibilitychange', handleVisibilityChange);
            
            // ç›‘å¬é¡µé¢å…³é—­
            window.addEventListener('beforeunload', handleBeforeUnload);
            
            // åˆå§‹åŒ–æ—¶è·å–éŸ³é¢‘è®¾å¤‡åˆ—è¡¨
            await refreshAudioDevices();
            
            // ç›‘å¬è®¾å¤‡å˜åŒ–
            if (navigator.mediaDevices && navigator.mediaDevices.addEventListener) {
                navigator.mediaDevices.addEventListener('devicechange', handleDeviceChange);
            }
            
            // æ£€æµ‹æµè§ˆå™¨å¯¹ç³»ç»ŸéŸ³é¢‘æ•è·çš„æ”¯æŒ
            checkSystemAudioSupport();
            
            console.log('é¡µé¢åˆå§‹åŒ–å®Œæˆ');
        });
        
        // æ£€æµ‹ç³»ç»ŸéŸ³é¢‘æ”¯æŒ
        function checkSystemAudioSupport() {
            // æ£€æŸ¥getDisplayMediaæ”¯æŒï¼ˆç”¨äºç³»ç»ŸéŸ³é¢‘å’Œå±å¹•éŸ³é¢‘ï¼‰
            if (!navigator.mediaDevices || !navigator.mediaDevices.getDisplayMedia) {
                systemAudioSourceOption.style.opacity = '0.5';
                systemAudioSourceOption.style.cursor = 'not-allowed';
                systemAudioSourceRadio.disabled = true;
                
                screenAudioSourceOption.style.opacity = '0.5';
                screenAudioSourceOption.style.cursor = 'not-allowed';
                screenAudioSourceRadio.disabled = true;
                
                micScreenSourceOption.style.opacity = '0.5';
                micScreenSourceOption.style.cursor = 'not-allowed';
                micScreenSourceRadio.disabled = true;
            }
        }
        
        // å¤„ç†é¡µé¢å¯è§æ€§å˜åŒ–
        function handleVisibilityChange() {
            if (document.hidden && isInCall) {
                console.log('é¡µé¢è¿›å…¥åå°ï¼Œé€šè¯ä¿æŒä¸­...');
            } else if (isInCall) {
                console.log('é¡µé¢å›åˆ°å‰å°');
            }
        }
        
        // å¤„ç†é¡µé¢å…³é—­
        function handleBeforeUnload(e) {
            if (isInCall) {
                const confirmationMessage = 'æ‚¨æ­£åœ¨é€šè¯ä¸­ï¼Œç¡®å®šè¦ç¦»å¼€å—ï¼Ÿ';
                e.returnValue = confirmationMessage;
                return confirmationMessage;
            }
        }
        
        // åˆå§‹åŒ–å®¢æˆ·ç«¯
        async function initRtcClient() {
            if (rtcClient) return;
            
            try {
                rtcClient = AgoraRTC.createClient({ mode: "rtc", codec: "vp8" });
                
                // ç›‘å¬è¿œç¨‹ç”¨æˆ·åŠ å…¥
                rtcClient.on("user-published", async (user, mediaType) => {
                    try {
                        await rtcClient.subscribe(user, mediaType);
                        if (mediaType === "audio") {
                            const remoteAudioTrack = user.audioTrack;
                            remoteAudioTrack.play();
                            
                            // æ·»åŠ è¿œç¨‹æˆå‘˜åˆ°åˆ—è¡¨
                            addMember(user.uid, false, remoteAudioTrack);
                            updateMembersDisplay();
                            console.log(`å·²è®¢é˜…è¿œç¨‹ç”¨æˆ· ${user.uid} çš„éŸ³é¢‘`);
                        }
                    } catch (subscribeErr) {
                        console.error("è®¢é˜…è¿œç¨‹ç”¨æˆ·å¤±è´¥ï¼š", subscribeErr);
                    }
                });
                
                // ç›‘å¬ç”¨æˆ·å–æ¶ˆå‘å¸ƒ
                rtcClient.on("user-unpublished", (user, mediaType) => {
                    const member = members.get(user.uid.toString());
                    if (member && !member.isLocal) {
                        member.isMuted = true;
                        updateMembersDisplay();
                        console.log(`ç”¨æˆ· ${user.uid} å·²å…³é—­éº¦å…‹é£`);
                    }
                });
                
                // ç›‘å¬ç”¨æˆ·ç¦»å¼€é¢‘é“
                rtcClient.on("user-left", (user) => {
                    removeMember(user.uid);
                    updateMembersDisplay();
                    console.log(`ç”¨æˆ· ${user.uid} å·²ç¦»å¼€é¢‘é“`);
                });
                
                // ç›‘å¬ç”¨æˆ·é‡æ–°å‘å¸ƒåª’ä½“æµ
                rtcClient.on("user-published", async (user, mediaType) => {
                    if (mediaType === "audio" && members.has(user.uid.toString())) {
                        try {
                            await rtcClient.subscribe(user, mediaType);
                            const remoteAudioTrack = user.audioTrack;
                            remoteAudioTrack.play();
                            
                            const member = members.get(user.uid.toString());
                            if (member) {
                                member.audioTrack = remoteAudioTrack;
                                member.isMuted = false;
                                updateMembersDisplay();
                                console.log(`ç”¨æˆ· ${user.uid} é‡æ–°å¼€å¯éº¦å…‹é£`);
                            }
                        } catch (subscribeErr) {
                            console.error("é‡æ–°è®¢é˜…ç”¨æˆ·å¤±è´¥ï¼š", subscribeErr);
                        }
                    }
                });
                
            } catch (initErr) {
                console.error("å®¢æˆ·ç«¯åˆå§‹åŒ–å¤±è´¥ï¼š", initErr);
                throw initErr;
            }
        }
        
        // æ–°å¢ï¼šåª’ä½“æºå˜æ›´å¤„ç†
        function onAudioSourceChange(event) {
            const selectedSource = event.target.value;
            currentAudioSource = selectedSource;
            
            // æ›´æ–°UIçŠ¶æ€
            updateSourceUI(selectedSource);
            
            // å¦‚æœåœ¨é€šè¯ä¸­ï¼Œé‡æ–°åˆ›å»ºéŸ³é¢‘è½¨é“
            if (isInCall && localAudioTrack) {
                switchAudioSource(selectedSource);
            }
        }
        
        // æ–°å¢ï¼šæ›´æ–°åª’ä½“æºUI
        function updateSourceUI(source) {
            // ç§»é™¤æ‰€æœ‰activeç±»
            micSourceOption.classList.remove('active');
            systemAudioSourceOption.classList.remove('active');
            screenAudioSourceOption.classList.remove('active');
            micScreenSourceOption.classList.remove('active');
            
            // ä¸ºå½“å‰é€‰ä¸­çš„æºæ·»åŠ activeç±»
            if (source === 'microphone') {
                micSourceOption.classList.add('active');
                // å¯ç”¨éº¦å…‹é£é€‰æ‹©
                micSelect.disabled = false;
            } else if (source === 'system') {
                systemAudioSourceOption.classList.add('active');
                // ç¦ç”¨éº¦å…‹é£é€‰æ‹©ï¼ˆç³»ç»ŸéŸ³é¢‘ä½¿ç”¨é»˜è®¤è®¾å¤‡ï¼‰
                micSelect.disabled = true;
            } else if (source === 'screen') {
                screenAudioSourceOption.classList.add('active');
                // ç¦ç”¨éº¦å…‹é£é€‰æ‹©ï¼ˆå±å¹•éŸ³é¢‘ä½¿ç”¨å±å¹•å…±äº«ï¼‰
                micSelect.disabled = true;
            } else if (source === 'mic+screen') {
                micScreenSourceOption.classList.add('active');
                // å¯ç”¨éº¦å…‹é£é€‰æ‹©ï¼ˆéœ€è¦é€‰æ‹©éº¦å…‹é£è®¾å¤‡ï¼‰
                micSelect.disabled = false;
            }
        }
        
        // æ–°å¢ï¼šéŸ³é¢‘å¤„ç†é€‰é¡¹å˜æ›´
        function onAudioProcessingChange(event) {
            audioProcessingOptions.AEC = aecToggle.checked;
            audioProcessingOptions.ANS = ansToggle.checked;
            audioProcessingOptions.AGC = agcToggle.checked;
            
            // æ›´æ–°UIçŠ¶æ€
            updateProcessingUI();
            
            console.log('éŸ³é¢‘å¤„ç†é€‰é¡¹å·²æ›´æ–°:', audioProcessingOptions);
            
            // å¦‚æœåœ¨é€šè¯ä¸­ï¼Œé‡æ–°åº”ç”¨éŸ³é¢‘å¤„ç†
            if (isInCall && localAudioTrack && (currentAudioSource === 'microphone' || currentAudioSource === 'mic+screen')) {
                applyAudioProcessing();
            }
        }
        
        // æ–°å¢ï¼šæ›´æ–°éŸ³é¢‘å¤„ç†UI
        function updateProcessingUI() {
            if (audioProcessingOptions.AEC) {
                aecOption.classList.add('active');
            } else {
                aecOption.classList.remove('active');
            }
            
            if (audioProcessingOptions.ANS) {
                ansOption.classList.add('active');
            } else {
                ansOption.classList.remove('active');
            }
            
            if (audioProcessingOptions.AGC) {
                agcOption.classList.add('active');
            } else {
                agcOption.classList.remove('active');
            }
        }
        
        // æ–°å¢ï¼šåˆ‡æ¢éŸ³é¢‘æº
        async function switchAudioSource(sourceType) {
            if (!isInCall) {
                return;
            }
            
            try {
                console.log('åˆ‡æ¢éŸ³é¢‘æºåˆ°:', sourceType);
                
                // åœæ­¢å½“å‰çš„éº¦å…‹é£æµ‹è¯•
                stopMicTest();
                
                // å…³é—­å½“å‰è½¨é“
                if (localAudioTrack) {
                    // å…ˆå–æ¶ˆå‘å¸ƒ
                    if (isPublished) {
                        await rtcClient.unpublish([localAudioTrack]);
                    }
                    
                    localAudioTrack.close();
                    localAudioTrack = null;
                }
                
                // å…³é—­å±å¹•éŸ³é¢‘è½¨é“
                if (localScreenAudioTrack) {
                    localScreenAudioTrack.close();
                    localScreenAudioTrack = null;
                }
                
                // æ ¹æ®é€‰æ‹©çš„æºåˆ›å»ºæ–°è½¨é“
                let newAudioTrack;
                
                if (sourceType === 'microphone') {
                    // åˆ›å»ºéº¦å…‹é£éŸ³é¢‘è½¨é“
                    const microphoneConfig = {};
                    
                    if (selectedMicDeviceId) {
                        microphoneConfig.microphoneId = selectedMicDeviceId;
                    }
                    
                    // æ·»åŠ éŸ³é¢‘å¤„ç†é…ç½®
                    Object.assign(microphoneConfig, {
                        encoderConfig: 'music_standard',
                        AEC: audioProcessingOptions.AEC,
                        ANS: audioProcessingOptions.ANS,
                        AGC: audioProcessingOptions.AGC
                    });
                    
                    newAudioTrack = await AgoraRTC.createMicrophoneAudioTrack(microphoneConfig);
                    
                } else if (sourceType === 'system' || sourceType === 'screen') {
                    // å°è¯•æ•è·ç³»ç»ŸéŸ³é¢‘æˆ–å±å¹•éŸ³é¢‘
                    try {
                        const constraints = {
                            audio: true,
                            video: sourceType === 'screen'
                        };
                        
                        const stream = await navigator.mediaDevices.getDisplayMedia(constraints);
                        
                        // ä»streamä¸­è·å–éŸ³é¢‘è½¨é“
                        const audioTracks = stream.getAudioTracks();
                        if (audioTracks.length > 0) {
                            // ä½¿ç”¨Agoraçš„createCustomAudioTrackåˆ›å»ºè½¨é“
                            newAudioTrack = await AgoraRTC.createCustomAudioTrack({
                                mediaStreamTrack: audioTracks[0]
                            });
                            
                            // ä¿å­˜å±å¹•å…±äº«æµï¼ˆå¦‚æœéœ€è¦åœæ­¢ï¼‰
                            if (sourceType === 'screen') {
                                localScreenAudioTrack = newAudioTrack;
                            }
                        } else {
                            throw new Error('æœªæ•è·åˆ°éŸ³é¢‘è½¨é“');
                        }
                    } catch (error) {
                        console.error('æ•è·ç³»ç»Ÿ/å±å¹•éŸ³é¢‘å¤±è´¥:', error);
                        alert(`æ— æ³•æ•è·${sourceType === 'system' ? 'ç³»ç»Ÿ' : 'å±å¹•'}éŸ³é¢‘: ${error.message}`);
                        
                        // å›é€€åˆ°éº¦å…‹é£
                        micSourceRadio.checked = true;
                        currentAudioSource = 'microphone';
                        updateSourceUI('microphone');
                        await switchAudioSource('microphone');
                        return;
                    }
                } else if (sourceType === 'mic+screen') {
                    // åˆ›å»ºè¯ç­’+å±å¹•éŸ³é¢‘æ··åˆè½¨é“
                    newAudioTrack = await createMixedAudioTrack();
                }
                
                if (!newAudioTrack) {
                    throw new Error('éŸ³é¢‘è½¨é“åˆ›å»ºå¤±è´¥');
                }
                
                // è®¾ç½®æ–°è½¨é“
                localAudioTrack = newAudioTrack;
                
                // é‡æ–°å‘å¸ƒ
                if (isPublished) {
                    await rtcClient.publish([localAudioTrack]);
                    
                    // æ›´æ–°é™éŸ³çŠ¶æ€
                    localAudioTrack.setEnabled(!isMicrophoneMuted);
                } else {
                    localAudioTrack.setEnabled(!isMicrophoneMuted);
                }
                
                // æ›´æ–°æœ¬åœ°æˆå‘˜çš„éŸ³é¢‘è½¨é“å¼•ç”¨
                const localMember = Array.from(members.values()).find(m => m.isLocal);
                if (localMember) {
                    localMember.audioTrack = localAudioTrack;
                }
                
                console.log('éŸ³é¢‘æºåˆ‡æ¢æˆåŠŸ');
                updateCallStatus('connected', `å·²åˆ‡æ¢åˆ°${getSourceName(sourceType)}`);
                
            } catch (error) {
                console.error('åˆ‡æ¢éŸ³é¢‘æºå¤±è´¥:', error);
                updateCallStatus('error', `éŸ³é¢‘æºåˆ‡æ¢å¤±è´¥: ${error.message}`);
                
                // å›é€€åˆ°éº¦å…‹é£
                micSourceRadio.checked = true;
                currentAudioSource = 'microphone';
                updateSourceUI('microphone');
            }
        }
        
        // æ–°å¢ï¼šåˆ›å»ºæ··åˆéŸ³é¢‘è½¨é“ï¼ˆè¯ç­’+å±å¹•éŸ³é¢‘ï¼‰
        async function createMixedAudioTrack() {
            try {
                // 1. è·å–éº¦å…‹é£éŸ³é¢‘æµ
                const microphoneConfig = {};
                
                if (selectedMicDeviceId) {
                    microphoneConfig.microphoneId = selectedMicDeviceId;
                }
                
                // æ·»åŠ éŸ³é¢‘å¤„ç†é…ç½®
                Object.assign(microphoneConfig, {
                    encoderConfig: 'music_standard',
                    AEC: audioProcessingOptions.AEC,
                    ANS: audioProcessingOptions.ANS,
                    AGC: audioProcessingOptions.AGC
                });
                
                const micStream = await navigator.mediaDevices.getUserMedia({
                    audio: microphoneConfig
                });
                
                // 2. è·å–å±å¹•éŸ³é¢‘æµ
                const screenStream = await navigator.mediaDevices.getDisplayMedia({
                    audio: true,
                    video: true
                });
                
                // 3. åˆ›å»ºéŸ³é¢‘ä¸Šä¸‹æ–‡æ¥æ··åˆä¸¤ä¸ªéŸ³é¢‘æµ
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                // 4. åˆ›å»ºéŸ³é¢‘æºèŠ‚ç‚¹
                const micSource = audioContext.createMediaStreamSource(micStream);
                const screenSource = audioContext.createMediaStreamSource(screenStream);
                
                // 5. åˆ›å»ºç›®æ ‡èŠ‚ç‚¹ï¼ˆç”¨äºè¾“å‡ºæ··åˆåçš„éŸ³é¢‘ï¼‰
                const destination = audioContext.createMediaStreamDestination();
                
                // 6. è¿æ¥éŸ³é¢‘æºåˆ°ç›®æ ‡èŠ‚ç‚¹
                micSource.connect(destination);
                screenSource.connect(destination);
                
                // 7. ä»ç›®æ ‡èŠ‚ç‚¹è·å–æ··åˆåçš„éŸ³é¢‘è½¨é“
                const mixedStream = destination.stream;
                const mixedAudioTrack = mixedStream.getAudioTracks()[0];
                
                // 8. ä¿å­˜å±å¹•å…±äº«æµä»¥ä¾¿åç»­å…³é—­
                localScreenAudioTrack = {
                    close: function() {
                        // åœæ­¢æ‰€æœ‰è½¨é“
                        micStream.getTracks().forEach(track => track.stop());
                        screenStream.getTracks().forEach(track => track.stop());
                        audioContext.close();
                    }
                };
                
                // 9. åˆ›å»ºAgoraè‡ªå®šä¹‰éŸ³é¢‘è½¨é“
                return await AgoraRTC.createCustomAudioTrack({
                    mediaStreamTrack: mixedAudioTrack
                });
                
            } catch (error) {
                console.error('åˆ›å»ºæ··åˆéŸ³é¢‘è½¨é“å¤±è´¥:', error);
                throw new Error(`æ— æ³•åˆ›å»ºæ··åˆéŸ³é¢‘: ${error.message}`);
            }
        }
        
        // æ–°å¢ï¼šè·å–åª’ä½“æºåç§°
        function getSourceName(sourceType) {
            switch(sourceType) {
                case 'microphone': return 'éº¦å…‹é£';
                case 'system': return 'ç³»ç»ŸéŸ³é¢‘';
                case 'screen': return 'å±å¹•éŸ³é¢‘';
                case 'mic+screen': return 'è¯ç­’+å±å¹•éŸ³é¢‘';
                default: return 'æœªçŸ¥æº';
            }
        }
        
        // æ–°å¢ï¼šåº”ç”¨éŸ³é¢‘å¤„ç†
        async function applyAudioProcessing() {
            if (!localAudioTrack || (currentAudioSource !== 'microphone' && currentAudioSource !== 'mic+screen')) {
                return;
            }
            
            try {
                // é‡æ–°åˆ›å»ºéŸ³é¢‘è½¨é“ä»¥åº”ç”¨æ–°çš„å¤„ç†é€‰é¡¹
                await switchAudioSource(currentAudioSource);
            } catch (error) {
                console.error('åº”ç”¨éŸ³é¢‘å¤„ç†å¤±è´¥:', error);
            }
        }
        
        // åˆ·æ–°éŸ³é¢‘è®¾å¤‡åˆ—è¡¨
        async function refreshAudioDevices() {
            if (!refreshDevicesBtn) return;
            
            refreshDevicesBtn.disabled = true;
            refreshDevicesBtn.innerHTML = '<i class="fas fa-circle-notch fa-spin"></i> è·å–ä¸­...';
            
            try {
                // å…ˆæ£€æŸ¥éº¦å…‹é£æƒé™
                try {
                    await navigator.mediaDevices.getUserMedia({ audio: true });
                } catch (err) {
                    console.warn('éº¦å…‹é£æƒé™æœªæˆæƒ:', err);
                }
                
                // è·å–æ‰€æœ‰éŸ³é¢‘è®¾å¤‡
                const devices = await navigator.mediaDevices.enumerateDevices();
                
                // åˆ†ç¦»è¾“å…¥å’Œè¾“å‡ºè®¾å¤‡
                audioInputDevices = devices.filter(device => device.kind === 'audioinput');
                audioOutputDevices = devices.filter(device => device.kind === 'audiooutput');
                
                console.log('éŸ³é¢‘è¾“å…¥è®¾å¤‡:', audioInputDevices);
                console.log('éŸ³é¢‘è¾“å‡ºè®¾å¤‡:', audioOutputDevices);
                
                // æ›´æ–°éº¦å…‹é£é€‰æ‹©ä¸‹æ‹‰æ¡†
                updateDeviceSelect(micSelect, audioInputDevices, selectedMicDeviceId, 'ä½¿ç”¨é»˜è®¤éº¦å…‹é£');
                
                // æ›´æ–°æ‰¬å£°å™¨é€‰æ‹©ä¸‹æ‹‰æ¡†
                updateDeviceSelect(speakerSelect, audioOutputDevices, selectedSpeakerDeviceId, 'ä½¿ç”¨é»˜è®¤æ‰¬å£°å™¨');
                
                // æ›´æ–°è®¾å¤‡çŠ¶æ€æ˜¾ç¤º
                updateDeviceStatus();
                
                // æ ¹æ®å½“å‰åª’ä½“æºå¯ç”¨/ç¦ç”¨éº¦å…‹é£é€‰æ‹©
                micSelect.disabled = audioInputDevices.length === 0 || 
                                    (currentAudioSource !== 'microphone' && currentAudioSource !== 'mic+screen');
                speakerSelect.disabled = audioOutputDevices.length === 0;
                
            } catch (error) {
                console.error('è·å–éŸ³é¢‘è®¾å¤‡å¤±è´¥:', error);
                showDeviceError('æ— æ³•è·å–éŸ³é¢‘è®¾å¤‡åˆ—è¡¨');
            } finally {
                refreshDevicesBtn.disabled = false;
                refreshDevicesBtn.innerHTML = '<i class="fas fa-sync-alt"></i> åˆ·æ–°è®¾å¤‡åˆ—è¡¨';
            }
        }
        
        // æ›´æ–°è®¾å¤‡é€‰æ‹©ä¸‹æ‹‰æ¡†
        function updateDeviceSelect(selectElement, devices, selectedId, defaultText) {
            if (!selectElement) return;
            
            // æ¸…ç©ºç°æœ‰é€‰é¡¹
            selectElement.innerHTML = '';
            
            if (devices.length === 0) {
                selectElement.innerHTML = `<option value="">æœªæ£€æµ‹åˆ°è®¾å¤‡</option>`;
                return;
            }
            
            // æ·»åŠ é»˜è®¤é€‰é¡¹
            const defaultOption = document.createElement('option');
            defaultOption.value = '';
            defaultOption.textContent = defaultText;
            selectElement.appendChild(defaultOption);
            
            // æ·»åŠ è®¾å¤‡é€‰é¡¹
            devices.forEach(device => {
                const option = document.createElement('option');
                option.value = device.deviceId;
                
                // å¦‚æœæœ‰è®¾å¤‡æ ‡ç­¾ï¼Œä½¿ç”¨æ ‡ç­¾ï¼Œå¦åˆ™ä½¿ç”¨è®¾å¤‡IDçš„ä¸€éƒ¨åˆ†
                let deviceName = device.label || `éŸ³é¢‘è®¾å¤‡ ${device.deviceId.substring(0, 8)}...`;
                
                // æ¸…ç†è®¾å¤‡åç§°
                if (deviceName.includes('Default') || deviceName.includes('é»˜è®¤')) {
                    deviceName = deviceName.replace(/\(.*?\)/g, '').trim();
                }
                
                option.textContent = deviceName;
                
                if (device.deviceId === selectedId) {
                    option.selected = true;
                }
                
                selectElement.appendChild(option);
            });
        }
        
        // æ›´æ–°è®¾å¤‡çŠ¶æ€æ˜¾ç¤º
        function updateDeviceStatus() {
            if (!micStatusDiv || !speakerStatusDiv) return;
            
            // éº¦å…‹é£çŠ¶æ€
            if (selectedMicDeviceId && audioInputDevices.some(d => d.deviceId === selectedMicDeviceId)) {
                const selectedMic = audioInputDevices.find(d => d.deviceId === selectedMicDeviceId);
                let deviceName = selectedMic.label || 'éº¦å…‹é£';
                deviceName = deviceName.replace(/\(.*?\)/g, '').trim();
                micStatusDiv.className = 'device-status active';
                micStatusDiv.innerHTML = `<i class="fas fa-check-circle"></i> å·²é€‰æ‹©: ${deviceName.substring(0, 30)}`;
            } else {
                micStatusDiv.className = 'device-status inactive';
                micStatusDiv.innerHTML = `<i class="fas fa-circle"></i> ä½¿ç”¨é»˜è®¤éº¦å…‹é£`;
            }
            
            // æ‰¬å£°å™¨çŠ¶æ€
            if (selectedSpeakerDeviceId && audioOutputDevices.some(d => d.deviceId === selectedSpeakerDeviceId)) {
                const selectedSpeaker = audioOutputDevices.find(d => d.deviceId === selectedSpeakerDeviceId);
                let deviceName = selectedSpeaker.label || 'æ‰¬å£°å™¨';
                deviceName = deviceName.replace(/\(.*?\)/g, '').trim();
                speakerStatusDiv.className = 'device-status active';
                speakerStatusDiv.innerHTML = `<i class="fas fa-check-circle"></i> å·²é€‰æ‹©: ${deviceName.substring(0, 30)}`;
            } else {
                speakerStatusDiv.className = 'device-status inactive';
                speakerStatusDiv.innerHTML = `<i class="fas fa-circle"></i> ä½¿ç”¨é»˜è®¤æ‰¬å£°å™¨`;
            }
        }
        
        // éº¦å…‹é£è®¾å¤‡å˜æ›´å¤„ç†
        async function onMicDeviceChange(event) {
            selectedMicDeviceId = event.target.value;
            updateDeviceStatus();
            
            // å¦‚æœåœ¨é€šè¯ä¸­ï¼Œé‡æ–°åˆ›å»ºéŸ³é¢‘è½¨é“
            if (isInCall && localAudioTrack && (currentAudioSource === 'microphone' || currentAudioSource === 'mic+screen')) {
                await switchMicrophoneDevice();
            }
        }
        
        // æ‰¬å£°å™¨è®¾å¤‡å˜æ›´å¤„ç†
        async function onSpeakerDeviceChange(event) {
            selectedSpeakerDeviceId = event.target.value;
            updateDeviceStatus();
            
            // è®¾ç½®éŸ³é¢‘è¾“å‡ºè®¾å¤‡
            await setAudioOutputDevice();
        }
        
        // è®¾å¤‡å˜åŒ–ç›‘å¬
        function handleDeviceChange() {
            console.log('æ£€æµ‹åˆ°éŸ³é¢‘è®¾å¤‡å˜åŒ–ï¼Œé‡æ–°è·å–è®¾å¤‡åˆ—è¡¨');
            refreshAudioDevices();
        }
        
        // æ˜¾ç¤ºè®¾å¤‡é”™è¯¯
        function showDeviceError(message) {
            if (micSelect) {
                micSelect.innerHTML = `<option value="">${message}</option>`;
                micSelect.disabled = true;
            }
            
            if (speakerSelect) {
                speakerSelect.innerHTML = `<option value="">${message}</option>`;
                speakerSelect.disabled = true;
            }
        }
        
        // åˆ‡æ¢éº¦å…‹é£è®¾å¤‡
        async function switchMicrophoneDevice() {
            if (!isInCall || !localAudioTrack || (currentAudioSource !== 'microphone' && currentAudioSource !== 'mic+screen')) {
                return;
            }
            
            try {
                console.log('åˆ‡æ¢éº¦å…‹é£è®¾å¤‡:', selectedMicDeviceId);
                
                // åœæ­¢å½“å‰çš„éº¦å…‹é£æµ‹è¯•
                stopMicTest();
                
                // é‡æ–°åˆ›å»ºéŸ³é¢‘è½¨é“
                await switchAudioSource(currentAudioSource);
                
                console.log('éº¦å…‹é£è®¾å¤‡åˆ‡æ¢æˆåŠŸ');
                updateCallStatus('connected', 'éº¦å…‹é£è®¾å¤‡å·²åˆ‡æ¢');
                
            } catch (error) {
                console.error('åˆ‡æ¢éº¦å…‹é£è®¾å¤‡å¤±è´¥:', error);
                updateCallStatus('error', `éº¦å…‹é£åˆ‡æ¢å¤±è´¥: ${error.message}`);
                
                // æ¢å¤åŸè®¾å¤‡é€‰æ‹©
                micSelect.value = '';
                selectedMicDeviceId = '';
                updateDeviceStatus();
            }
        }
        
        // è®¾ç½®éŸ³é¢‘è¾“å‡ºè®¾å¤‡
        async function setAudioOutputDevice() {
            if (!selectedSpeakerDeviceId) {
                // ä½¿ç”¨é»˜è®¤è®¾å¤‡
                try {
                    if (localAudioTrack && localAudioTrack.setPlaybackDevice) {
                        await localAudioTrack.setPlaybackDevice('default');
                    }
                    
                    members.forEach(member => {
                        if (member.audioTrack && !member.isLocal && member.audioTrack.setPlaybackDevice) {
                            member.audioTrack.setPlaybackDevice('default');
                        }
                    });
                    
                    console.log('éŸ³é¢‘è¾“å‡ºè®¾å¤‡å·²æ¢å¤ä¸ºé»˜è®¤');
                } catch (error) {
                    console.warn('è®¾ç½®é»˜è®¤éŸ³é¢‘è¾“å‡ºè®¾å¤‡å¤±è´¥:', error);
                }
                return;
            }
            
            try {
                if (localAudioTrack && localAudioTrack.setPlaybackDevice) {
                    await localAudioTrack.setPlaybackDevice(selectedSpeakerDeviceId);
                }
                
                members.forEach(member => {
                    if (member.audioTrack && !member.isLocal && member.audioTrack.setPlaybackDevice) {
                        member.audioTrack.setPlaybackDevice(selectedSpeakerDeviceId);
                    }
                });
                
                console.log('éŸ³é¢‘è¾“å‡ºè®¾å¤‡å·²åˆ‡æ¢:', selectedSpeakerDeviceId);
                
            } catch (error) {
                console.error('åˆ‡æ¢éŸ³é¢‘è¾“å‡ºè®¾å¤‡å¤±è´¥:', error);
                speakerSelect.value = '';
                selectedSpeakerDeviceId = '';
                updateDeviceStatus();
            }
        }
        
        // åˆ‡æ¢éº¦å…‹é£æµ‹è¯•
        async function toggleMicTest() {
            if (isTestingMic) {
                stopMicTest();
            } else {
                await startMicTest();
            }
        }
        
        // å¼€å§‹éº¦å…‹é£æµ‹è¯•
        async function startMicTest() {
            if (currentAudioSource !== 'microphone') {
                alert('éº¦å…‹é£æµ‹è¯•ä»…é€‚ç”¨äºçº¯éº¦å…‹é£æº');
                return;
            }
            
            if (!selectedMicDeviceId && audioInputDevices.length > 0) {
                selectedMicDeviceId = audioInputDevices[0].deviceId;
                micSelect.value = selectedMicDeviceId;
                updateDeviceStatus();
            }
            
            if (!selectedMicDeviceId) {
                alert('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªéº¦å…‹é£è®¾å¤‡è¿›è¡Œæµ‹è¯•');
                return;
            }
            
            testMicBtn.disabled = true;
            testMicBtn.innerHTML = '<i class="fas fa-circle-notch fa-spin"></i> å‡†å¤‡ä¸­...';
            
            try {
                const constraints = {
                    audio: {
                        deviceId: selectedMicDeviceId ? { exact: selectedMicDeviceId } : undefined,
                        echoCancellation: false,
                        noiseSuppression: false,
                        autoGainControl: false
                    }
                };
                
                testAudioStream = await navigator.mediaDevices.getUserMedia(constraints);
                
                testAudioContext = new (window.AudioContext || window.webkitAudioContext)();
                const source = testAudioContext.createMediaStreamSource(testAudioStream);
                testAudioAnalyser = testAudioContext.createAnalyser();
                
                source.connect(testAudioAnalyser);
                testAudioAnalyser.fftSize = 256;
                
                volumeMeter.style.display = 'block';
                volumeLevel.style.width = '0%';
                
                isTestingMic = true;
                testMicBtn.disabled = false;
                testMicBtn.innerHTML = '<i class="fas fa-stop"></i> åœæ­¢æµ‹è¯•';
                
                updateVolumeMeter();
                
                console.log('éº¦å…‹é£æµ‹è¯•å¼€å§‹');
                
            } catch (error) {
                console.error('éº¦å…‹é£æµ‹è¯•å¤±è´¥:', error);
                alert(`éº¦å…‹é£æµ‹è¯•å¤±è´¥: ${error.message}`);
                testMicBtn.disabled = false;
                testMicBtn.innerHTML = '<i class="fas fa-play"></i> æµ‹è¯•éº¦å…‹é£';
            }
        }
        
        // åœæ­¢éº¦å…‹é£æµ‹è¯•
        function stopMicTest() {
            if (testAudioContext) {
                testAudioContext.close();
                testAudioContext = null;
                testAudioAnalyser = null;
            }
            
            if (testAudioStream) {
                testAudioStream.getTracks().forEach(track => track.stop());
                testAudioStream = null;
            }
            
            volumeMeter.style.display = 'none';
            volumeLevel.style.width = '0%';
            
            isTestingMic = false;
            if (testMicBtn) {
                testMicBtn.disabled = false;
                testMicBtn.innerHTML = '<i class="fas fa-play"></i> æµ‹è¯•éº¦å…‹é£';
            }
            
            console.log('éº¦å…‹é£æµ‹è¯•åœæ­¢');
        }
        
        // æ›´æ–°éŸ³é‡æ˜¾ç¤º
        function updateVolumeMeter() {
            if (!isTestingMic || !testAudioAnalyser) return;
            
            const dataArray = new Uint8Array(testAudioAnalyser.frequencyBinCount);
            testAudioAnalyser.getByteFrequencyData(dataArray);
            
            let sum = 0;
            for (let i = 0; i < dataArray.length; i++) {
                sum += dataArray[i];
            }
            const average = sum / dataArray.length;
            const volume = Math.min(100, Math.round((average / 128) * 100));
            
            volumeLevel.style.width = volume + '%';
            
            requestAnimationFrame(updateVolumeMeter);
        }
        
        // æ·»åŠ æˆå‘˜
        function addMember(uid, isLocal = false, audioTrack = null) {
            if (members.has(uid.toString())) {
                const existingMember = members.get(uid.toString());
                existingMember.audioTrack = audioTrack;
                existingMember.isMuted = false;
            } else {
                const member = {
                    uid: uid,
                    isLocal: isLocal,
                    audioTrack: audioTrack,
                    isMuted: false,
                    isSpeaking: false
                };
                members.set(uid.toString(), member);
            }
        }
        
        // ç§»é™¤æˆå‘˜
        function removeMember(uid) {
            members.delete(uid.toString());
        }
        
        // æ›´æ–°æˆå‘˜æ˜¾ç¤º
        function updateMembersDisplay() {
            if (!membersListDiv || !memberCountSpan) {
                console.warn('æˆå‘˜åˆ—è¡¨å…ƒç´ æœªæ‰¾åˆ°');
                return;
            }
            
            if (members.size === 0) {
                membersListDiv.innerHTML = `
                    <div class="empty-state">
                        <i class="fas fa-user-friends"></i>
                        <p>é¢‘é“å†…æš‚æ— æˆå‘˜</p>
                        <p style="font-size: 12px; margin-top: 5px;">åŠ å…¥é¢‘é“åï¼Œæˆå‘˜åˆ—è¡¨å°†åœ¨è¿™é‡Œæ˜¾ç¤º</p>
                    </div>
                `;
                memberCountSpan.textContent = "0";
                return;
            }
            
            memberCountSpan.textContent = members.size.toString();
            
            let membersHTML = "";
            
            members.forEach(member => {
                const isLocal = member.isLocal;
                const uid = member.uid;
                
                const colors = ['#667eea', '#764ba2', '#4CAF50', '#FF9800', '#E91E63', '#9C27B0'];
                const colorIndex = parseInt(uid) % colors.length || 0;
                
                let statusClass = "status-online";
                let statusText = "åœ¨çº¿";
                let statusIcon = "fa-circle";
                
                let isActuallyMuted = member.isMuted;
                if (isLocal) {
                    isActuallyMuted = isMicrophoneMuted;
                }
                
                if (isActuallyMuted) {
                    statusClass = "status-muted";
                    statusText = "å·²é™éŸ³";
                    statusIcon = "fa-microphone-slash";
                } else if (member.isSpeaking) {
                    statusClass = "status-speaker";
                    statusText = "æ­£åœ¨å‘è¨€";
                    statusIcon = "fa-volume-up";
                }
                
                const muteIcon = isActuallyMuted ? 'fa-microphone-slash' : 'fa-microphone';
                const muteTitle = isActuallyMuted ? 'å–æ¶ˆé™éŸ³' : 'é™éŸ³';
                const muteBtnClass = isActuallyMuted ? 'mute-btn muted' : 'mute-btn';
                
                membersHTML += `
                    <div class="member-card ${isLocal ? 'local' : ''}">
                        <div class="avatar ${isLocal ? 'local' : 'remote'}" style="background: ${colors[colorIndex]}">
                            ${isLocal ? 'æˆ‘' : 'ç”¨æˆ·'}
                        </div>
                        <div class="member-info">
                            <div class="member-name">
                                ${isLocal ? 'æˆ‘ (æœ¬åœ°)' : `ç”¨æˆ· ${uid}`}
                            </div>
                            <div class="member-uid">UID: ${uid}</div>
                            <div class="member-status ${statusClass}">
                                <i class="fas ${statusIcon}"></i>
                                ${statusText}
                            </div>
                        </div>
                        <div class="member-actions">
                            <button class="action-btn ${muteBtnClass}" 
                                    onclick="toggleMemberMute('${uid}')" 
                                    title="${muteTitle}"
                                    ${isLocal ? 'disabled' : ''}>
                                <i class="fas ${muteIcon}"></i>
                            </button>
                        </div>
                    </div>
                `;
            });
            
            membersListDiv.innerHTML = membersHTML;
        }
        
        // åˆ‡æ¢æˆå‘˜é™éŸ³
        window.toggleMemberMute = function(uid) {
            const member = members.get(uid);
            if (!member) return;
            
            if (member.isLocal) {
                toggleMicrophone();
            } else {
                if (member.audioTrack) {
                    if (member.isMuted) {
                        member.audioTrack.play();
                    } else {
                        member.audioTrack.stop();
                    }
                    member.isMuted = !member.isMuted;
                    updateMembersDisplay();
                }
            }
        };
        
        // æ£€æµ‹éº¦å…‹é£æƒé™
        async function checkMicPermission() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                stream.getTracks().forEach(track => track.stop());
                return true;
            } catch (e) {
                alert(`éº¦å…‹é£æƒé™æ£€æµ‹å¤±è´¥ï¼š${e.message}\nè¯·æ£€æŸ¥ï¼š1.æµè§ˆå™¨æƒé™ 2.éHTTPç¯å¢ƒï¼ˆéœ€HTTPS/localhostï¼‰`);
                console.error("éº¦å…‹é£æƒé™å¤±è´¥ï¼š", e);
                return false;
            }
        }
        
        // æ›´æ–°é€šè¯çŠ¶æ€æ˜¾ç¤º
        function updateCallStatus(status, message) {
            if (!callStatusDiv || !statusTextSpan) return;
            
            callStatusDiv.style.display = 'block';
            callStatusDiv.className = 'call-status';
            
            if (status === 'connecting') {
                statusTextSpan.innerHTML = `<i class="fas fa-circle-notch fa-spin"></i> ${message}`;
            } else if (status === 'connected') {
                callStatusDiv.classList.add('connected');
                statusTextSpan.innerHTML = `<i class="fas fa-check-circle"></i> ${message}`;
            } else if (status === 'disconnected') {
                callStatusDiv.classList.add('disconnected');
                statusTextSpan.innerHTML = `<i class="fas fa-times-circle"></i> ${message}`;
            } else if (status === 'error') {
                callStatusDiv.classList.add('disconnected');
                statusTextSpan.innerHTML = `<i class="fas fa-exclamation-circle"></i> ${message}`;
            }
            
            if (status === 'connected' || status === 'error') {
                setTimeout(() => {
                    if (callStatusDiv && (callStatusDiv.classList.contains('connected') || 
                         callStatusDiv.classList.contains('disconnected'))) {
                        callStatusDiv.style.display = 'none';
                    }
                }, 5000);
            }
        }
        
        // åˆ‡æ¢é€šè¯çŠ¶æ€
        async function toggleCall() {
            if (!callToggleBtn || !micToggleBtn) return;
            
            if (isInCall) {
                await leaveChannel();
            } else {
                await joinChannel();
            }
        }
        
        // åŠ å…¥é¢‘é“
        async function joinChannel() {
            if (!channelNameInput) {
                alert("æ— æ³•è·å–é¢‘é“è¾“å…¥æ¡†");
                return;
            }
            
            const channelName = channelNameInput.value.trim();
            if (!channelName) {
                alert("è¯·è¾“å…¥æœ‰æ•ˆçš„é¢‘é“åï¼");
                return;
            }
            
            // æ ¹æ®é€‰æ‹©çš„åª’ä½“æºæ£€æµ‹æƒé™
            if (currentAudioSource === 'microphone' || currentAudioSource === 'mic+screen') {
                const hasMicPerm = await checkMicPermission();
                if (!hasMicPerm) return;
            }
            
            updateCallStatus('connecting', 'æ­£åœ¨åŠ å…¥é¢‘é“...');
            callToggleBtn.disabled = true;
            
            try {
                await initRtcClient();
                
                // æ ¹æ®é€‰æ‹©çš„åª’ä½“æºåˆ›å»ºéŸ³é¢‘è½¨é“
                let audioTrack;
                
                if (currentAudioSource === 'microphone') {
                    const microphoneConfig = {};
                    
                    if (selectedMicDeviceId) {
                        microphoneConfig.microphoneId = selectedMicDeviceId;
                    }
                    
                    // æ·»åŠ éŸ³é¢‘å¤„ç†é…ç½®
                    Object.assign(microphoneConfig, {
                        encoderConfig: 'music_standard',
                        AEC: audioProcessingOptions.AEC,
                        ANS: audioProcessingOptions.ANS,
                        AGC: audioProcessingOptions.AGC
                    });
                    
                    audioTrack = await AgoraRTC.createMicrophoneAudioTrack(microphoneConfig);
                    
                } else if (currentAudioSource === 'system' || currentAudioSource === 'screen') {
                    // å°è¯•æ•è·ç³»ç»ŸéŸ³é¢‘æˆ–å±å¹•éŸ³é¢‘
                    try {
                        const constraints = {
                            audio: true,
                            video: currentAudioSource === 'screen'
                        };
                        
                        const stream = await navigator.mediaDevices.getDisplayMedia(constraints);
                        const audioTracks = stream.getAudioTracks();
                        
                        if (audioTracks.length > 0) {
                            audioTrack = await AgoraRTC.createCustomAudioTrack({
                                mediaStreamTrack: audioTracks[0]
                            });
                            
                            if (currentAudioSource === 'screen') {
                                localScreenAudioTrack = audioTrack;
                            }
                        } else {
                            throw new Error('æœªæ•è·åˆ°éŸ³é¢‘è½¨é“');
                        }
                    } catch (error) {
                        console.error('æ•è·ç³»ç»Ÿ/å±å¹•éŸ³é¢‘å¤±è´¥:', error);
                        alert(`æ— æ³•æ•è·${currentAudioSource === 'system' ? 'ç³»ç»Ÿ' : 'å±å¹•'}éŸ³é¢‘: ${error.message}\nå°†åˆ‡æ¢åˆ°éº¦å…‹é£æ¨¡å¼`);
                        
                        // åˆ‡æ¢åˆ°éº¦å…‹é£æ¨¡å¼
                        micSourceRadio.checked = true;
                        currentAudioSource = 'microphone';
                        updateSourceUI('microphone');
                        
                        // é‡æ–°å°è¯•åŠ å…¥ï¼ˆç®€åŒ–å¤„ç†ï¼‰
                        callToggleBtn.disabled = false;
                        updateCallStatus('error', 'éŸ³é¢‘æºä¸å¯ç”¨ï¼Œè¯·åˆ‡æ¢åé‡è¯•');
                        return;
                    }
                } else if (currentAudioSource === 'mic+screen') {
                    // åˆ›å»ºè¯ç­’+å±å¹•éŸ³é¢‘æ··åˆè½¨é“
                    audioTrack = await createMixedAudioTrack();
                }
                
                if (!audioTrack || !audioTrack.play) {
                    throw new Error("éŸ³é¢‘è½¨é“åˆ›å»ºå¤±è´¥ï¼šéæœ‰æ•ˆè½¨é“å®ä¾‹");
                }
                
                localAudioTrack = audioTrack;
                console.log(`${getSourceName(currentAudioSource)}éŸ³é¢‘è½¨é“åˆ›å»ºæˆåŠŸ`);
                
                // è·å–ç”¨æˆ·è¾“å…¥çš„Token
                const userToken = tokenInput.value.trim();
                const token = userToken || null;
                
                // åŠ å…¥é¢‘é“
                const uid = await rtcClient.join(APP_ID, channelName, token);
                console.log(`åŠ å…¥é¢‘é“ã€${channelName}ã€‘æˆåŠŸï¼ŒUID: ${uid}`);
                
                // æ·»åŠ æœ¬åœ°æˆå‘˜åˆ°åˆ—è¡¨
                addMember(uid, true, localAudioTrack);
                updateMembersDisplay();
                
                // å‘å¸ƒéŸ³é¢‘
                if (!isPublished) {
                    await rtcClient.publish([localAudioTrack]);
                    isPublished = true;
                    console.log("æœ¬åœ°éŸ³é¢‘å‘å¸ƒæˆåŠŸ");
                    
                    micTextSpan.textContent = 'å…³é—­è¯ç­’';
                    micToggleBtn.classList.add('muted');
                    micToggleBtn.querySelector('i').className = 'fas fa-microphone-slash';
                    localAudioTrack.setEnabled(true);
                    isMicrophoneMuted = false;
                    
                    const localMember = Array.from(members.values()).find(m => m.isLocal);
                    if (localMember) {
                        localMember.isMuted = false;
                        updateMembersDisplay();
                    }
                }
                
                // è®¾ç½®éŸ³é¢‘è¾“å‡ºè®¾å¤‡
                await setAudioOutputDevice();
                
                // æ›´æ–°é€šè¯çŠ¶æ€
                isInCall = true;
                
                // æ›´æ–°æŒ‰é’®çŠ¶æ€
                callToggleBtn.disabled = false;
                callToggleBtn.classList.add('in-call');
                callTextSpan.textContent = 'é€€å‡ºé€šè¯';
                callToggleBtn.querySelector('i').className = 'fas fa-phone-slash';
                
                // å¯ç”¨è¯ç­’æŒ‰é’®
                micToggleBtn.disabled = false;
                
                // æ›´æ–°çŠ¶æ€æ˜¾ç¤º
                updateCallStatus('connected', `å·²åŠ å…¥é¢‘é“ï¼š${channelName} | UIDï¼š${uid} | éŸ³é¢‘æºï¼š${getSourceName(currentAudioSource)}`);
                
            } catch (e) {
                console.error("åŠ å…¥/å‘å¸ƒå¤±è´¥ï¼ˆè¯¦ç»†ä¿¡æ¯ï¼‰ï¼š", {
                    message: e.message,
                    code: e.code,
                    stack: e.stack
                });
                
                let errMsg = `åŠ å…¥é€šè¯å¤±è´¥ï¼š${e.message}`;
                if (e.code === "INVALID_PARAMS") {
                    errMsg += "\nåŸå› ï¼šå‘å¸ƒçš„è½¨é“éæœ‰æ•ˆæœ¬åœ°è½¨é“ï¼ˆè½¨é“åˆ›å»ºå¤±è´¥/å‚æ•°æ ¼å¼é”™è¯¯ï¼‰";
                } else if (e.code === "CAN_NOT_GET_GATEWAY_SERVER") {
                    errMsg += "\nåŸå› ï¼šToken/é¢‘é“å/AppID ä¸åŒ¹é…ï¼Œæˆ–é‰´æƒæ¨¡å¼å†²çª";
                } else if (e.message.includes("permission")) {
                    errMsg += "\nåŸå› ï¼šéº¦å…‹é£æƒé™è¢«æ‹’ç»";
                } else if (e.message.includes("token")) {
                    errMsg += "\nåŸå› ï¼šTokenæ— æ•ˆæˆ–è¿‡æœŸï¼Œè¯·æ£€æŸ¥å¹¶é‡æ–°è¾“å…¥";
                }
                
                callToggleBtn.disabled = false;
                isInCall = false;
                
                updateCallStatus('error', errMsg);
                
                if (localAudioTrack) {
                    localAudioTrack.close();
                    localAudioTrack = null;
                }
                isPublished = false;
            }
        }
        
        // åˆ‡æ¢éº¦å…‹é£å¼€å…³
        function toggleMicrophone() {
            if (!localAudioTrack || !micToggleBtn || !micTextSpan) return;
            
            if (isMicrophoneMuted) {
                localAudioTrack.setEnabled(true);
                micToggleBtn.querySelector('i').className = 'fas fa-microphone-slash';
                micTextSpan.textContent = 'å…³é—­è¯ç­’';
                micToggleBtn.classList.add('muted');
                console.log("éº¦å…‹é£å·²å¼€å¯");
                
                const localMember = Array.from(members.values()).find(m => m.isLocal);
                if (localMember) {
                    localMember.isMuted = false;
                }
            } else {
                localAudioTrack.setEnabled(false);
                micToggleBtn.querySelector('i').className = 'fas fa-microphone';
                micTextSpan.textContent = 'å¼€å¯è¯ç­’';
                micToggleBtn.classList.remove('muted');
                console.log("éº¦å…‹é£å·²å…³é—­");
                
                const localMember = Array.from(members.values()).find(m => m.isLocal);
                if (localMember) {
                    localMember.isMuted = true;
                }
            }
            
            isMicrophoneMuted = !isMicrophoneMuted;
            updateMembersDisplay();
        }
        
        // é€€å‡ºé¢‘é“
        async function leaveChannel() {
            try {
                stopMicTest();
                
                updateCallStatus('connecting', 'æ­£åœ¨ç¦»å¼€é¢‘é“...');
                callToggleBtn.disabled = true;
                
                if (localAudioTrack) {
                    localAudioTrack.close();
                    localAudioTrack = null;
                    console.log("æœ¬åœ°éŸ³é¢‘è½¨é“å·²é‡Šæ”¾");
                }
                
                if (localScreenAudioTrack) {
                    localScreenAudioTrack.close();
                    localScreenAudioTrack = null;
                    console.log("å±å¹•éŸ³é¢‘è½¨é“å·²é‡Šæ”¾");
                }
                
                if (rtcClient) {
                    await rtcClient.leave();
                    rtcClient = null;
                    console.log("å·²é€€å‡ºé¢‘é“");
                }
                
                members.clear();
                updateMembersDisplay();
                
                isPublished = false;
                isMicrophoneMuted = true;
                isInCall = false;
                
                callToggleBtn.disabled = false;
                callToggleBtn.classList.remove('in-call');
                callTextSpan.textContent = 'åŠ å…¥é€šè¯';
                callToggleBtn.querySelector('i').className = 'fas fa-phone-alt';
                
                micToggleBtn.disabled = true;
                micToggleBtn.querySelector('i').className = 'fas fa-microphone';
                micTextSpan.textContent = 'å¼€å¯è¯ç­’';
                micToggleBtn.classList.remove('muted');
                
                updateCallStatus('disconnected', 'å·²é€€å‡ºé€šè¯');
                
            } catch (leaveErr) {
                console.error("é€€å‡ºé¢‘é“å¤±è´¥ï¼š", leaveErr);
                updateCallStatus('error', `é€€å‡ºé€šè¯å¤±è´¥ï¼š${leaveErr.message}`);
                callToggleBtn.disabled = false;
            }
        }
        
        // è®©å‡½æ•°åœ¨å…¨å±€å¯ç”¨
        window.toggleCall = toggleCall;
        window.toggleMicrophone = toggleMicrophone;
    </script>
</body>
</html>